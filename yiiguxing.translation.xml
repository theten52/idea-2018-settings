<application>
  <component name="AppStorage">
    <histories>
      <item value="so that we don't get into trouble later in the run loop if there's memory shortage while loadinginitializing them lazily." />
      <item value="pre-load and initialize InterruptedException and Cleaner classes" />
      <item value="discovered" />
      <item value="Mark Reinhold" />
      <item value="prev Deadline Nanos" />
      <item value="MAX SCHEDULED TIMERFD NS" />
      <item value="Ratio" />
      <item value="io Ratio" />
      <item value="Ensure JNI is initialized by the time this class is loaded by this time! We use unix-common methods in this class which are backed by JNI methods" />
      <item value="Let the caller handle the interruption." />
      <item value="Deprecated Gradle features were used in this build, making it incompatible with Gradle 7.0." />
      <item value="JVM-private state that persists after native thread termination." />
      <item value="The object in which this thread is blocked in an interruptible IO operation, if any. The blocker's interrupt method should be invoked after setting this thread's interrupt status." />
      <item value="Set the blocker field; invoked via sun.misc.SharedSecrets from java.nio code" />
      <item value="weak Compare And Set" />
      <item value="interrupted" />
      <item value="Just to set the interrupt flag" />
      <item value="argument" />
      <item value="Lock methods The value 0 represents the unlocked state. The value 1 represents the locked state." />
      <item value="Try to signal next queued node if: Propagation was indicated by caller, or was recorded (as h.waitStatus either before or after setHead) by a previous operation (note: this uses sign-check of waitStatus because PROPAGATE status may transition to SIGNAL.) and The next node is waiting in shared mode, or we don't know, because it appears null The conservatism in both of these checks may cause unnecessary wake-ups, but only when there are multiple racing acquiresreleases, so most need signals now or soon anyway." />
      <item value="acquire Uninterruptibly" />
      <item value="Semaphore" />
      <item value="set Head And Propagate" />
      <item value="uninterruptible" />
      <item value="Thread to unpark is held in successor, which is normally just the next node. But if cancelled or apparently null, traverse backwards from tail to find the actual non-cancelled successor." />
      <item value="If successor needs signal" />
      <item value="If we are the tail, remove ourselves." />
      <item value="Hot Spot Intrinsic Candidate" />
      <item value="Plain accessors" />
      <item value="Constable" />
      <item value="Var Handle" />
      <item value="throw new Error(&quot;Maximum lock count exceeded&quot;);" />
      <item value="overflow" />
      <item value="{ While we must in general read state before owner, we don't need to do so to check if current thread is owner" />
      <item value="While we must in general read state before owner," />
      <item value="synchronization" />
      <item value="Decrement count; signal when transition to zero" />
      <item value="If lastWaiter is cancelled, clean out." />
      <item value="serving" />
      <item value="Must initialize" />
      <item value="insert" />
      <item value="suffices" />
      <item value="estimate" />
      <item value="rough" />
      <item value="if synchronization is held exclusively;" />
      <item value="internally" />
      <item value="Returns {@code true} if synchronization is held exclusively with respect to the current (calling) thread." />
      <item value="respect" />
      <item value="exclusively" />
      <item value="held" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1184" />
        <entry key="ENGLISH" value="1185" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="7" />
        <entry key="FRENCH" value="3" />
        <entry key="GALICIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="JAPANESE" value="1" />
        <entry key="ESPERANTO" value="2" />
        <entry key="ITALIAN" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1614960720453" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200402000411101" />
      </app-key>
    </option>
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="20200402000411101" />
      </youdao-translate>
    </option>
  </component>
</application>