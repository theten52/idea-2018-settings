<application>
  <component name="AppStorage">
    <option name="newTranslationDialogX" value="1005" />
    <option name="newTranslationDialogY" value="145" />
    <histories>
      <item value="variable" />
      <item value="extract" />
      <item value="Corrupted STDOUT by directly writing to native stream in forked JVM 1. See FAQ web page and the dump file Users" />
      <item value="Corrupted" />
      <item value="map Alternative Name" />
      <item value="library Path" />
      <item value="requires Dependency Collection" />
      <item value="instantiation Strategy" />
      <item value="requires Dependency Resolution" />
      <item value="The Resources Plugin handles the copying of project resources to the output directory. There are two different kinds of resources: main resources and test resources. The difference is that the main resources are the resources associated with the main source code while the test resources are associated with the test source code. Thus, this allows the separation of resources for the main source code and its unit tests." />
      <item value="Create proxy if we have advice." />
      <item value="Create proxy here if we have a custom TargetSource. Suppresses unnecessary default instantiation of the target bean: The TargetSource will handle target instances in a custom fashion." />
      <item value="finish Bean Factory Initialization" />
      <item value="Register bean processors that intercept bean creation." />
      <item value="apply Bean Post Processors Before Initialization" />
      <item value="Initialize the bean instance." />
      <item value="is Singleton Currently In Creation" />
      <item value="Eagerly cache singletons to be able to resolve circular references even when triggered by lifecycle interfaces like BeanFactoryAware." />
      <item value="Allow post-processors to modify the merged bean definition." />
      <item value="Don't override the class with CGLIB if no overrides." />
      <item value="Guarantee initialization of beans that the current bean depends on." />
      <item value="is Prototype Currently In Creation" />
      <item value="Temporarily return non-post-processed object, not storing it yet.." />
      <item value="Do not accept a null value for a FactoryBean that's not fully initialized yet: Many FactoryBeans just return null then." />
      <item value="already There" />
      <item value="get Singleton Mutex" />
      <item value="contains Bean Definition" />
      <item value="synthetic" />
      <item value="Now we have the bean instance, which may be a normal bean or a FactoryBean. If it's a FactoryBean, we use it to create a bean instance, unless the caller actually wants a reference to the factory." />
      <item value="which may be a normal bean or a FactoryBean." />
      <item value="Don't let calling code try to dereference the factory if the bean isn't a factory." />
      <item value="a consequence of a circular reference" />
      <item value="canonical Name" />
      <item value="compute If Absent" />
      <item value="Eagerly check singleton cache for manually registered singletons" />
      <item value="Activate" />
      <item value="get Supported Extensions" />
      <item value="cache Default Extension Name" />
      <item value="get Adaptive Extension" />
      <item value="try to load from ExtensionLoader's ClassLoader first" />
      <item value="get Adaptive Extension Class" />
      <item value="create Adaptive Extension" />
      <item value="cached Activates" />
      <item value="load Initial Drivers" />
      <item value="Balanced Clickhouse Driver" />
      <item value="is Driver Allowed" />
      <item value="Load the initial JDBC drivers by checking the System property jdbc.properties and then use the {@code ServiceLoader} mechanism" />
      <item value="Attempts to locate a driver that understands the given URL" />
      <item value="Load these drivers, so that they can be instantiated. It may be the case that the driver class may not be there i.e. there may be a packaged driver with the service class as implementation of java.sql.Driver but the actual class may be missing. In that case a java.util.ServiceConfigurationError will be thrown at runtime by the VM trying to locate and load the service. Adding a try catch block to catch those runtime errors if driver not available in classpath but it's packaged as service and that service is there in classpath." />
      <item value="If the driver is packaged as a Service Provider, load it. Get all the drivers through the classloader exposed as a java.sql.Driver.class service. ServiceLoader.load() replaces the sun.misc.Providers()" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="1448" />
        <entry key="ENGLISH" value="1449" />
        <entry key="ESTONIAN" value="1" />
        <entry key="GERMAN" value="7" />
        <entry key="FRENCH" value="3" />
        <entry key="GALICIAN" value="1" />
        <entry key="LATIN" value="1" />
        <entry key="NORWEGIAN" value="1" />
        <entry key="JAPANESE" value="1" />
        <entry key="ESPERANTO" value="2" />
        <entry key="ITALIAN" value="3" />
      </map>
    </option>
  </component>
  <component name="Cache">
    <option name="lastTrimTime" value="1622308955793" />
  </component>
  <component name="Settings">
    <option name="baiduTranslateSettings">
      <app-key>
        <option name="appId" value="20200402000411101" />
      </app-key>
    </option>
    <option name="translateDocumentation" value="true" />
    <option name="translator" value="YOUDAO" />
    <option name="youdaoTranslateSettings">
      <youdao-translate>
        <option name="appId" value="3e88577f0b42e0b4" />
      </youdao-translate>
    </option>
  </component>
</application>